<!doctype html>

<html lang="en">  
<head>  
<meta charset="utf-8" />  
<meta name="viewport" content="width=device-width,initial-scale=1" />  
<title>Login — Crypto Training</title>  
<link rel="icon" href="/logo.png">  
<style>  
  :root{ --bg:#071024; --card:#062035; --accent:#06b6d4; --danger:#ef4444; --text:#e6eef8; }  
  body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#031025,#071024); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Arial; }  
  .card{ width:92vw; max-width:420px; background:linear-gradient(180deg,#071a2b,#041324); border-radius:12px; padding:20px; box-shadow:0 8px 30px rgba(2,6,23,0.6); }  
  .logo{ display:block; margin:4px auto 12px; width:120px; height:auto }  
  h1{ text-align:center; margin:4px 0 8px; font-size:20px; }  
  .pin{ width:100%; padding:12px 14px; font-size:20px; border-radius:10px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:var(--text); text-align:center; letter-spacing:6px }  
  button{ width:100%; margin-top:12px; padding:12px; border-radius:10px; border:0; background:var(--accent); color:#042a2b; font-weight:800; cursor:pointer; font-size:16px }  
  .msg{ margin-top:12px; text-align:center; font-size:14px; color:rgba(230,238,248,0.9) }  
  .small{ margin-top:8px; font-size:12px; opacity:0.85; text-align:center }  
  a.link{ color:#9be7ff; text-decoration:none }  
  .fp { font-family:monospace; word-break:break-all; font-size:11px; background:#02121a; padding:8px; border-radius:8px; margin-top:10px; display:none }  

  /* Modal styles (minimal, matching your UI) */
  .modal-backdrop{ position:fixed; inset:0; background:rgba(2,6,23,0.6); display:none; align-items:center; justify-content:center; z-index:9999; }
  .modal-panel{ background:#0b1220; padding:18px; border-radius:10px; width:92%; max-width:520px; box-shadow:0 12px 40px rgba(0,0,0,0.6); color:#e6eef8; }
  .modal-title{ font-weight:800; margin-bottom:8px; font-size:1.05rem }
  .modal-body{ margin-bottom:12px; color:#cfefff; line-height:1.3 }
  .modal-actions{ display:flex; gap:8px; justify-content:flex-end; }
  .btn-secondary{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfefff; padding:8px 10px; border-radius:8px; cursor:pointer }
  .btn-primary{ background:linear-gradient(90deg,#06b6d4,#0891b2); color:#042a2b; padding:8px 12px; border-radius:8px; font-weight:800; cursor:pointer }
</style>  
</head>  
<body>  
  <div class="card" role="main" aria-labelledby="title">  
    <img src="  https://i.postimg.cc/x1cLbZhh/IMG-20250812-WA0070.jpg " alt="logo" class="logo" onerror="this.style.display='none'">  
    <h1 id="title">Enter 6-digit PIN</h1>  
    <input id="pin" class="pin" maxlength="6" inputmode="numeric" pattern="\d{6}" placeholder="●●●●●●" autocomplete="one-time-code" aria-label="6-digit PIN">  

    <button id="btn">Login</button>  
    <div class="msg" id="msg">PIN is single-device. If used elsewhere it will be revoked.</div>  
    <div class="small">Don't have a PIN? <a class="link" href="/payment">Buy course / Payment</a></div>  

    <div class="fp" id="fpBox" title="Device fingerprint (for server lock)"></div>
  </div>  

  <!-- Modal markup -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal-panel" role="document" aria-live="polite" aria-modal="true">
      <div class="modal-title" id="modalTitle">Title</div>
      <div class="modal-body" id="modalBody">Message</div>
      <div class="modal-actions" id="modalActions">
        <button class="btn-secondary" id="modalCancel">Cancel</button>
        <button class="btn-primary" id="modalOk">OK</button>
      </div>
    </div>
  </div>

<script>  
(async function(){  
  // ------------- CONFIG -------------  
  const RENDER_HOST = 'bewise-trading-and-investment-institution.onrender.com';  
  const RENDER_BASE = 'https://' + RENDER_HOST;  
  const RENDER_API = RENDER_BASE + '/api';  

  // If page served from Render host use relative /api; otherwise use Render absolute API.  
  const API = (location.hostname === RENDER_HOST) ? '/api' : RENDER_API;  
  const UI_BASE = (location.hostname === RENDER_HOST) ? '' : RENDER_BASE;  
  // ----------------------------------  

  const pinInput = document.getElementById('pin');  
  const btn = document.getElementById('btn');  
  const msg = document.getElementById('msg');  
  const fpBox = document.getElementById('fpBox');

  // Modal helpers (replaces alert)
  const backdrop = document.getElementById('modalBackdrop');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');
  const modalOk = document.getElementById('modalOk');
  const modalCancel = document.getElementById('modalCancel');

  function showModal(title, message, { showCancel=false, okText='OK', cancelText='Cancel' } = {}){
    modalTitle.innerText = title || '';
    modalBody.innerText = message || '';
    modalOk.innerText = okText;
    modalCancel.innerText = cancelText;
    modalCancel.style.display = showCancel ? 'inline-block' : 'none';
    backdrop.style.display = 'flex';
    backdrop.setAttribute('aria-hidden','false');
    return new Promise((resolve)=>{
      function cleanup(){
        modalOk.removeEventListener('click', onOk);
        modalCancel.removeEventListener('click', onCancel);
        backdrop.style.display = 'none';
        backdrop.setAttribute('aria-hidden','true');
      }
      function onOk(){ cleanup(); resolve(true); }
      function onCancel(){ cleanup(); resolve(false); }
      modalOk.addEventListener('click', onOk);
      modalCancel.addEventListener('click', onCancel);
    });
  }
  const showMessage = (t,m) => showModal(t,m,{showCancel:false,okText:'OK'});
  const showConfirm = (t,m) => showModal(t,m,{showCancel:true,okText:'Yes',cancelText:'No'});

  // non-blocking status modal controls (for waiting while backend wakes)
  function showStatus(title, message, { showCancel=false, cancelHandler=null } = {}){
    modalTitle.innerText = title || '';
    modalBody.innerText = message || '';
    modalOk.style.display = 'none'; // hide OK for status modal
    modalCancel.style.display = showCancel ? 'inline-block' : 'none';
    backdrop.style.display = 'flex';
    backdrop.setAttribute('aria-hidden','false');
    // attach temporary cancel handler if provided
    if(showCancel && typeof cancelHandler === 'function'){
      modalCancel.addEventListener('click', cancelHandler);
    }
    return {
      update(msgText){
        modalBody.innerText = msgText;
      },
      close(){
        // remove any cancel listeners (best-effort)
        modalCancel.replaceWith(modalCancel.cloneNode(true));
        // restore nodes
        const newCancel = document.getElementById('modalCancel');
        modalOk.style.display = ''; // show OK back to default state
        backdrop.style.display = 'none';
        backdrop.setAttribute('aria-hidden','true');
      }
    };
  }

  function computeFingerprint(){  
    let uuid = localStorage.getItem('training_device_uuid');  
    if(!uuid){  
      uuid = (crypto.randomUUID ? crypto.randomUUID() : ('u-'+Math.random().toString(36).slice(2)));  
      localStorage.setItem('training_device_uuid', uuid);  
    }  
    const parts = [  
      navigator.userAgent || '',  
      navigator.platform || '',  
      (navigator.languages || []).join(','),  
      screen.width + 'x' + screen.height + 'x' + screen.colorDepth,  
      Intl.DateTimeFormat().resolvedOptions().timeZone || '',  
      uuid  
    ].join('||');  
    const enc = new TextEncoder().encode(parts);  
    return crypto.subtle.digest('SHA-256', enc).then(hashBuf => {
      return Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2,'0')).join('');
    });
  }  

  // Enhanced checkSessionOnLoad that waits/polls if server is asleep / Render interstitial HTML appears.
  async function checkSessionOnLoad(){
    const maxAttempts = 120; // upper limit (e.g., ~4 minutes with 2s backoff), adjustable if desired
    let attempt = 0;
    let delay = 1000; // start 1s
    let statusHandle = null;
    let canceled = false;

    // cancel handler for status modal
    function onCancelWait(){
      canceled = true;
      if(statusHandle) statusHandle.close();
    }

    while(attempt < maxAttempts && !canceled){
      attempt++;
      try {
        const res = await fetch(API + '/check_session', { credentials: 'include' });
        // If we got an HTTP response, try to parse JSON. If it is JSON -> return it.
        const txt = await res.text();
        try {
          const j = JSON.parse(txt);
          // got JSON — close status if visible and return
          if(statusHandle) statusHandle.close();
          return j;
        } catch (parseErr){
          // Not JSON (likely HTML interstitial or Render verification page). Treat as server not ready.
          // Show or update status modal.
          if(!statusHandle){
            statusHandle = showStatus('Waking server', 'Backend appears to be sleeping/returning HTML. Waiting for backend to become available... (attempt ' + attempt + ')', { showCancel: true, cancelHandler: onCancelWait });
          } else {
            statusHandle.update('Backend appears to be sleeping/returning HTML. Waiting... (attempt ' + attempt + ')');
          }
          // fallthrough to wait-and-retry
        }
      } catch (err){
        // Network-level error (server down / DNS / CORS blocked). Show status and retry.
        if(!statusHandle){
          statusHandle = showStatus('Connecting', 'Unable to reach backend. Waiting for it to wake up... (attempt ' + attempt + ')', { showCancel: true, cancelHandler: onCancelWait });
        } else {
          statusHandle.update('Unable to reach backend. Waiting... (attempt ' + attempt + ')');
        }
      }

      // exponential backoff with cap
      await new Promise(r => setTimeout(r, delay));
      delay = Math.min(5000, Math.floor(delay * 1.2)); // gradually increase, cap 5s
    }

    // if we exit loop because canceled or attempts exhausted
    if(statusHandle) statusHandle.close();
    return null;
  }

  const fp = await computeFingerprint();  
  fpBox.textContent = fp;  

  // reveal fingerprint on long-press or ctrl+click  
  let holdTimer = null;  
  msg.addEventListener('mousedown', ()=>{ holdTimer = setTimeout(()=> fpBox.style.display='block', 600); });  
  msg.addEventListener('mouseup', ()=>{ clearTimeout(holdTimer); });  
  msg.addEventListener('mouseleave', ()=>{ clearTimeout(holdTimer); });  
  msg.addEventListener('click', (e)=>{ if(e.ctrlKey) fpBox.style.display = (fpBox.style.display==='block' ? 'none' : 'block'); });  

  const existing = await checkSessionOnLoad();  
  if(existing && existing.logged_in){  
    if(existing.is_admin){  
      sessionStorage.setItem('training_is_admin', '1');  
      location.replace(UI_BASE + '/admin');  
    } else {  
      location.replace(UI_BASE + '/dashboard');  
    }  
    return;  
  }  

  function showMsg(text, isErr){  
    msg.textContent = text;  
    msg.style.color = isErr ? '#ffb4b4' : '';  
  }  

  function validPin(v){ return /^\d{6}$/.test(v); }  

  btn.addEventListener('click', login);  
  pinInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') login(); });  

  async function login(){  
    const pin = (pinInput.value || '').trim();  
    if(!validPin(pin)){ showMsg('Enter a valid 6-digit PIN', true); return; }  
    showMsg('Logging in...');  
    btn.disabled = true;  

    try {  
      const payload = { pin: pin, device_id: fp };  
      const res = await fetch(API + '/login', {  
        method: 'POST',  
        headers: { 'Content-Type': 'application/json' },  
        body: JSON.stringify(payload),  
        credentials: 'include'  
      });  

      const text = await res.text();  
      let json = null;  
      try { json = JSON.parse(text); } catch(e){ json = { success:false, error:'invalid_response', raw:text }; }  

      if(!res.ok || !json.success){  
        const err = json.error || json.message || 'Login failed';  
        if(json.error === 'revoked_due_to_multiple_devices'){  
          showMsg('PIN revoked — it was used on another device.', true);  
        } else if(json.error === 'pin_revoked'){  
          showMsg('This PIN has been revoked.', true);  
        } else if(json.error === 'pin_not_found'){  
          showMsg('PIN not found. Buy access or contact admin.', true);  
        } else if(json.error === 'device_not_allowed'){  
          showMsg(json.message || 'Device not allowed', true);  
        } else {  
          showMsg(err, true);  
        }  
        btn.disabled = false;  
        return;  
      }  

      const role = json.role || (pin === '891959' ? 'admin' : 'user');  

      if(role === 'admin' || pin === '891959'){  
        sessionStorage.setItem('training_is_admin', '1');  
      } else {  
        sessionStorage.removeItem('training_is_admin');  
      }  

      try { localStorage.setItem('training_allowed_device', fp); } catch(e){}  

      // replaced alerts with modal popups (blocking by awaiting user)
      await showMessage('Welcome', 'Login successful.');
      await showMessage('Warning', 'PINs are single-device. Do not share your PIN. If used on another device it will be revoked.');

      if(role === 'admin' || pin === '891959'){  
        location.href = UI_BASE + '/admin';  
      } else {  
        location.href = UI_BASE + '/dashboard';  
      }  
    } catch(err){  
      console.error('login error', err);  
      showMsg('Network error — try again', true);  
    } finally {  
      btn.disabled = false;  
    }  
  }  

})();  
</script>  
</body>  
  </html>