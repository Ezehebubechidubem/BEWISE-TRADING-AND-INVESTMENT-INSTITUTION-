<!-- course.html -->
<!doctype html>
<html>
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Courses</title>
<link rel="icon" href="/logo.png">
<style>
  body{font-family:system-ui;margin:0;background:linear-gradient(180deg,#031025,#071024);color:#e6eef8}
  header{display:flex;align-items:center;gap:12px;padding:12px;background:linear-gradient(90deg,#06203a,#08304d)}
  .logo{height:36px}
  .wrap{padding:18px;max-width:1100px;margin:auto}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:14px}
  .card{background:#062035;padding:12px;border-radius:12px;position:relative;overflow:hidden}
  .player-canvas{width:100%;height:auto;border-radius:8px;background:black;display:block}
  .protect-overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    background:rgba(2,6,23,0.6);color:#fff;font-weight:700;font-size:1.1rem;
    z-index:40;backdrop-filter: blur(2px);display:none;
  }
  .title{margin-top:8px;font-weight:700}
  /* small hint */
  .note{opacity:0.85;font-size:0.95rem;margin-bottom:6px}
  /* prevent selection/long-press */
  video, canvas { -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }
</style>
</head>
<body>
<header><img src="/logo.png" class="logo"><div style="font-weight:700">Courses</div></header>
<div class="wrap">
  <p class="note">Watch course videos below. Download/capture is blocked where possible; videos are watermarked per session.</p>
  <div id="grid" class="grid"></div>
</div>

<script>
/*
 Deep-protection course page:
 - renders each <video> into a <canvas> (prevents standard saving and disables native controls)
 - overlays a moving forensic watermark (device short fingerprint + timestamp)
 - pauses/blurs on visibility change, window blur, devtools detection
 - disables context menu and common save keys (best-effort)
 - NOTE: absolute prevention of screenshots/OS-level recording is impossible from a webpage
*/

// helpers
async function computeFP(){
  let uuid = localStorage.getItem('training_device_uuid');
  if(!uuid){ uuid = crypto.randomUUID ? crypto.randomUUID() : ('u-'+Math.random().toString(36).slice(2)); localStorage.setItem('training_device_uuid', uuid); }
  const data = [navigator.userAgent||'', navigator.platform||'', (navigator.languages||[]).join(','), screen.width+'x'+screen.height+'x'+screen.colorDepth, Intl.DateTimeFormat().resolvedOptions().timeZone||'', uuid].join('||');
  const enc = new TextEncoder().encode(data);
  const hashBuf = await crypto.subtle.digest('SHA-256', enc);
  const hex = Array.from(new Uint8Array(hashBuf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  return hex;
}

function shortFP(fp){ return (fp||'').slice(0,8); }

// Draw loop for canvas from video
function attachProtectedPlayer(parentEl, videoSrc, titleText, sessionTag){
  // Hidden native video element (not shown to user, used as decoder)
  const video = document.createElement('video');
  video.src = videoSrc;
  video.crossOrigin = "anonymous";
  video.preload = "metadata";
  video.muted = false;
  video.playsInline = true;
  video.setAttribute('controls', ''); // allow user control via custom UI if desired (we don't show native controls)
  // but hide native controls visually by positioning offscreen
  video.style.position = 'absolute';
  video.style.left = '-9999px';
  video.style.width = '1px';
  video.style.height = '1px';
  video.style.opacity = '0';
  // create canvas for visible output
  const canvas = document.createElement('canvas');
  canvas.className = 'player-canvas';
  canvas.width = 640; // will resize
  canvas.height = 360;
  // overlay block when paused or hidden
  const overlay = document.createElement('div');
  overlay.className = 'protect-overlay';
  overlay.innerText = 'Protected content — playback paused';
  // title
  const title = document.createElement('div');
  title.className = 'title';
  title.innerText = titleText || 'Untitled';
  // assemble
  const wrapper = document.createElement('div');
  wrapper.className = 'card';
  wrapper.appendChild(video);
  wrapper.appendChild(canvas);
  wrapper.appendChild(overlay);
  wrapper.appendChild(title);
  parentEl.appendChild(wrapper);

  const ctx = canvas.getContext('2d');
  let rafId = null;
  let watermarkX = 20, watermarkY = 30;
  let dx = 0.4, dy = 0.25; // movement speed

  // adapt canvas size responsively
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(320, Math.floor(rect.width));
    // keep 16:9 based on width (optional)
    canvas.height = Math.floor(canvas.width * 9 / 16);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // drawing frame + watermark
  function drawFrame(){
    try {
      if(video.readyState >= 2){ // HAVE_CURRENT_DATA
        // draw video frame to canvas, scaled
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        // watermark (semi-transparent)
        ctx.save();
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = '#fffb';
        ctx.font = `${Math.max(12, Math.floor(canvas.width/45))}px system-ui, sans-serif`;
        const text = `${sessionTag} — ${new Date().toLocaleString()}`;
        // moving position
        watermarkX += dx;
        watermarkY += dy;
        if(watermarkX < 10 || watermarkX > canvas.width - 160) dx = -dx;
        if(watermarkY < 20 || watermarkY > canvas.height - 20) dy = -dy;
        // rotate slightly sometimes to make cropping harder
        ctx.translate(watermarkX, watermarkY);
        ctx.rotate(Math.sin(Date.now()/5000)*0.02);
        ctx.fillText(text, 0, 0);
        ctx.restore();
      } else {
        // optionally show blurred placeholder
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }
    } catch(e){
      // drawing might fail on cross-origin content if server blocks CORS
      // fallback: clear canvas
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }
    rafId = requestAnimationFrame(drawFrame);
  }

  // pause/show overlay logic
  function showOverlay(msg){
    overlay.innerText = msg || 'Protected content — playback paused';
    overlay.style.display = 'flex';
  }
  function hideOverlay(){
    overlay.style.display = 'none';
  }

  // Start playback and draw loop
  async function start(){
    hideOverlay();
    try {
      await video.play();
      if(rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(drawFrame);
    } catch(err){
      // autoplay may be blocked; show overlay and let user interact
      showOverlay('Tap to start playback');
    }
  }

  // Pause and stop drawing
  function stop(){
    try { video.pause(); } catch(e){}
    if(rafId) cancelAnimationFrame(rafId);
    showOverlay('Playback paused');
  }

  // Events to auto-pause on visibility/blur
  document.addEventListener('visibilitychange', ()=> {
    if(document.visibilityState !== 'visible'){ stop(); } else { /* do nothing; user may restart */ }
  });
  window.addEventListener('blur', ()=> stop());
  window.addEventListener('focus', ()=> { /* do nothing */ });

  // detect devtools (heuristic) and pause
  (function detectDevtools(){
    let open = false;
    const threshold = 160;
    setInterval(()=>{
      const widthDiff = window.outerWidth - window.innerWidth;
      const heightDiff = window.outerHeight - window.innerHeight;
      if(widthDiff > threshold || heightDiff > threshold){
        if(!open){ open = true; stop(); showOverlay('Playback blocked (devtools detected)'); }
      } else {
        if(open){ open = false; showOverlay('Playback paused'); } // keep paused to be safe
      }
    }, 1000);
  })();

  // quick toggle: clicking the canvas toggles play/pause
  canvas.addEventListener('click', async ()=>{
    if(video.paused){ await start(); } else { stop(); }
  });

  // attempt to detect PrintScreen key (best-effort)
  window.addEventListener('keydown', (e)=>{
    const key = e.key ? e.key.toLowerCase() : '';
    if(key === 'printscreen' || key === 'print' || (e.code && e.code.toLowerCase().includes('print'))){
      // briefly blank the canvas to discourage screenshot (not reliable)
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      setTimeout(()=>{ /* redraw will resume via raf loop if playing */ }, 500);
      e.preventDefault();
      e.stopPropagation();
    }
    // block common save/print combos
    if((e.ctrlKey||e.metaKey) && (e.key === 's' || e.key === 'S' || e.key === 'p' || e.key === 'P' || e.key === 'w' || e.key==='W')){
      e.preventDefault(); e.stopPropagation();
      showOverlay('This action is blocked on protected content');
    }
  }, true);

  // context menu disabled
  canvas.addEventListener('contextmenu', e=> e.preventDefault());
  wrapper.addEventListener('contextmenu', e=> e.preventDefault());

  // expose start/stop controls for admin/debug if needed
  return { video, canvas, start, stop, wrapper };
}

// Main flow
(async function main(){
  // session & device checks (reuse your existing flow)
  const fp = await computeFP();
  const allowed = localStorage.getItem('training_allowed_device');
  if(allowed && allowed !== fp){ alert('This installation is locked to another device.'); location.href='/'; return; }
  const chkRes = await fetch('/api/check_session');
  const chk = await chkRes.json();
  if(!chk.logged_in){ location.href='/'; return; }

  // fetch video list
  const res = await fetch('/api/videos');
  const vids = await res.json();
  const grid = document.getElementById('grid');
  if(!Array.isArray(vids) || vids.length===0){ grid.innerHTML = '<div style="opacity:0.8">No videos yet.</div>'; return; }

  // For each video create protected player
  for(const v of vids){
    // stream URL should be tokenized/short-lived in production. Here we use the /stream endpoint.
    const sessionTag = `ID:${shortFP(fp)}`;
    const src = '/stream/' + encodeURIComponent(v.id); // adjust to your backend
    attachProtectedPlayer(grid, src, v.title || 'Untitled', sessionTag);
  }
})();
})();
</script>
</body>
</html>